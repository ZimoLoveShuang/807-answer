# 习题5

## 题目1

### 问题描述

计算并输出1!＋2!＋…+n!(其中n<16)

### 题目分析

```text
显然，题意为求阶乘的和

由于，题目没说n的值具体是多少，于是n应该输入

然后，考虑怎么计算阶乘的和，显然应该用循环，依次把从1开始到n为止的阶乘值累加起来，最后输出结果即可

坑点：int型数据最大只能算到12的阶乘，13的阶乘就会溢出
```

### 解题思路

```text
1 定义n，int型，表示计算到n的阶乘为止，由用户输入
2 判定n，是否在合理的范围（0 < n < 16）
若在：继续接下来的步骤，否则退出
3 定义sum，long long型，初始值为0，用于记录累加的阶乘值
4 定义i，int型，依次计算i!累加到sum中
5 输出su
如何计算i的阶乘值：
1 定义t，long long型，初始值为1，用于记录累乘值
2 定义j，int型，取值[1,i]，依次计算t *= j
3 t的值即为i阶乘值
```

### 解题代码

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
    int n;
    long long sum = 0;
    int i, j;
    // 友好提示
    printf("请输入n，[1,15]\n");
    scanf("%d", &n);
    if (n < 1 || n > 15) {
        printf("输入不合法，应在[1,15]\n");
        exit(0);
    }
    // 保证数据在合理范围内的另外一种处理方式
    /*while (n < 1 || n > 15) {
        printf("输入不合法，应在[1,15]\n");
        scanf("%d", &n);
    }*/
    for (i = 1; i <= n; i++) {
        long long t = 1;
        for (j = 1; j <= i; j++) {
            t *= j;
        }
        sum += t;
    }
    printf("%lld\n", sum);
    return 0;
}
```

## 题目2

### 问题描述

输出1000以内的所有完数。“完数”是指一个数的因子之和等于自身

### 题目分析

```text
显而易见：题目要求我们输出1000以内的完数

但是题目给出的完数定义是有问题的，正确的定义应该是：“完数”是指一个数的因子（不包括自己）之和等于自身

比如6的因子有1 2 3 6，不包括本身的因子之和为1+2+3=6，所以6是一个完数

于是，我们只需要依次测试从0（其实可以是从2开始）开始到1000截止的每个数，算出该数的因子和，看看是否等于自身即可

另外可能需要说明的一点是，题目并不严谨，1000以内，包含负数不？相信很多同学可能有这个疑问，个人认为题目改为：输出1000以内的自然数中所有的完数，较好。吐槽一下，不必纠结，练习题而已
```

### 解题思路

```text
1 定义i，int型，初值为2，表示依次测试从2开始到1000截止的每个数
2 判定i，是否满足因子和等于自身
3 若满足，输出i
计算i的因子和：
4 定义sum，int型，初值为1，用于记录i的因子累加值
5 定义j，int型，初值为2，用于枚举i的每个因子
6 j依次取值[2,i / 2]，判定i % j是否为0，若是，累加到sum中
7 sum的值即为i的因子和
```

### 解题代码


```c
#include <stdio.h>

int main(void) {
    int i = 2, j;
    for (; i <= 1000; i++) {
        // j没必要从1开始，也没必要算到n - 1为止
        // 事实上1永远是自然数（非0）的因子，任何一个自然数n的因子（除本身之外）也不可能大于n/2，因此j只需要枚举到i/2即可
        int sum = 1;
        for (j = 2; j * 2 <= i; j++) {
            if (i % j == 0) {
                sum += j;
            }
        }
        // 当然，sum初值为0，j从1开始，枚举到i - 1这种做法也是对的
        /*int sum = 0;
        for (j = 1; j  < i; j++) {
            if (i % j == 0) {
                sum += j;
            }
        }*/
        if (sum == i) {
            printf("%d\n", i);
        }
    }
    return 0;
}
```

## 题目3

### 问题描述

输入两个正整数m和n,计算并输出其最大公约数。

### 题目分析

```text
经典题目，最大公约数(gcd问题)

提供几种参考做法

最为粗暴的想法是枚举，只需要依次枚举从min(m,n)减小到1为止的所有数，判定是否能同时被m，n整除，如果可以，直接输出即可（输出后算法结束）

另一个比较经典的做法是辗转相除法，原理是同余，不过多解释，我们来看一个例子，假定m，n分别是14 5，我们一直计算r = m % n，然后用计算后的n 和 r替换掉以前的m n，一直做这个运算，直到r为0，此时的n就是我们所求的最大公约数

m  n  r
14 5  4
5  4  1
4  1  0

如果m n的值变成5 14会发生什么有趣的现象呢？

m  n  r
5  14 5
14 5  4
5  4  1
4  1  0

可以看到，如果m比n小，那么第一次循环，会巧妙的交换m和n的值，其余过程完全一样
```

### 解题思路

```text
1 定义m，n，int型，要求用户输入
2 判定m，n是否均为正整数，若是，继续接下来的步骤，否则退出
3 定义r，int型，表示，m % n的余数
4 只要r不等于0，一直计算m = n;n = r;r = m % n;
5 当r为0时，n即为所求的最大公约数
6 输出n
```

### 解题代码

辗转相除

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
    int m, n, r;
    scanf("%d%d", &m, &n);
    if (m < 1 || n < 1) {
        printf("m或n的值不合法!\n");
        exit(0);
    }
    r = m % n;
    while (r) {
        m = n;
        n = r;
        r = m % n;
    }
    printf("%d", n);
    return 0;
}
```

暴力枚举

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
    int m, n, i;
    scanf("%d%d", &m, &n);
    if (m < 1 || n < 1) {
        printf("m或n的值不合法!\n");
        exit(0);
    }
    for (i = m < n ? m : n; i >= 1; i--) {
        if (m % i == 0 && n % i == 0) {
            printf("%d\n", i);
            break;
        }
    }
    return 0;
}
```

## 我想思路和题目分析的示例应该差不多了，同学们自己举一反三，后面的题目将只给出代码

## 题目4

### 问题描述

一个球从100米高度自由落下，每次落地后反跳回原高度的一半，再落下，再反弹。求它在第8次落地时共经过多少米，第8次反弹多高。

### 解题代码

```c
#include <stdio.h>

int main(void) {
    int i;
    float h = 100;
    float sum = h;
    for (i = 0; i < 8; i++) {
        h /= 2;
        sum += h;
    }
    printf("%f %f", sum, h);
    return 0;
}
```

## 题目5

### 问题描述

输入一行字符，分别统计其中英文字母、数字和其他字符的个数

### 解题代码

```c
#include <stdio.h>

#define LEN 200

int main(void) {
    char a[LEN];
    gets(a);
    int cnt_e = 0, cnt_n = 0, cnt_o = 0, i = 0;
    while (a[i] != '\0') {
        if (('a' <= a[i] && a[i] <= 'z') || ('A' <= a[i] && a[i] <= 'Z')) {
            cnt_e++;
        } else if ('0' <= a[i] && a[i] <= '9') {
            cnt_n++;
        } else {
            cnt_o++;
        }
        i++;
    }
    // 输出应该更友好一些，我只是懒
    printf("%d %d %d\n", cnt_e, cnt_n, cnt_o);
    return 0;
}
```

## 题目6

### 问题描述

从键盘输入任意个整数，以-888结束（不计入)，计算并输出其中的最大数和最小数。

### 解题代码

```c
#include <stdio.h>

#define INF 0x3fffffff

int main(void) {
    // 为什么INF要定义成0x3fffffff
    int max = -INF, min = INF, n;
    scanf("%d", &n);
    while (n != -888) {
        if (n > max) {
            max = n;
        }
        if (n < min) {
            min = n;
        }
        scanf("%d", &n);
    }
    // 为什么这里要判断一下，试试不判断 然后直接输入-888会怎么样
    if (min != INF) {
        printf("min = %d\n", min);
    }
    if (max != INF) {
        printf("max = %d\n", max);
    }
    return 0;
}
```

## 题目6

### 问题描述

要将100元钱换成1元、5元和10元的零钱，每种零钱的张数大于0，且为5(的倍数，编程输出所有可能的换法。

### 解题代码

```c
#include <stdio.h>

int main(void) {
    // i * 1 + j * 5 + k * 10 == 100
    int i, j, k;
    for (i = 5; i * 1 <= 100; i += 5) {
        for (j = 5; j * 5 <= 100; j += 5) {
            for (k = 5; k * 10 <= 100; k += 5) {
                if (i * 1 + j * 5 + k * 10 == 100) {
                    printf("%d %d %d\n", i, j, k);
                }
            }
        }
    }
    return 0;
}
```

## 题目7

### 问题描述

百钱百鸡问题。用100钱买100只鸡，公鸡一只五钱，母鸡一只三钱，小鸡三只一钱，编程输出所有可能的买法（要求每种鸡至少要买1只)

### 解题代码

```c
#include <stdio.h>

int main(void) {
    // i + j + k == 100
    // i * 5 + j * 3 + 1/3*k == 100
    // i * 15 + j * 9 + k == 300
    int i, j, k;
    for (i = 1; i * 15 <= 300; i++) {
        for (j = 1; j * 9 <= 300; j++) {
            for (k = 1; k * 1 <= 300; k++) {
                if ((i + j + k == 100) && (i * 15 + j * 9 + k == 300)) {
                    printf("%d %d %d\n", i, j, k);
                }
            }
        }
    }
    return 0;
}
```